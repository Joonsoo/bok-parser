// 우선순위 낮은것부터

Processor = Ref
  | '{' WS PExpr WS '}' $2

Ref: Ref = ValRef | RawRef
ValRef = '$' CondSymPath? RefIdx {ValRef(idx=$2, condSymPath=$1)}
CondSymPath: [%CondSymDir{BODY, COND}] = ('<' {%BODY} | '>' {%COND})+
RawRef = "\\$" CondSymPath? RefIdx {RawRef(idx=$2, condSymPath=$1)}

PExpr = TernateryExpr // TODO (WS ':' WS TypeDesc)? 를 뒤에 붙일 수 있을까?
TernateryExpr = BoolOrExpr WS '?' WS <TernateryExpr> WS ':' WS <TernateryExpr> {TerOp(cond=$0, then=$4, otherwise=$8)}
  | BoolOrExpr
BoolOrExpr = BoolAndExpr WS "&&" WS BoolOrExpr {BinOp(lhs=$0, rhs=$4, op=%Op.AND)}
  | BoolAndExpr
BoolAndExpr = BoolEqExpr WS "||" WS BoolAndExpr {BinOp(lhs=$0, rhs=$4, op=%Op.OR)}
  | BoolEqExpr
BoolEqExpr = ElvisExpr ("==" {%Op.EQ} | "!=" {%Op.NE}) WS BoolEqExpr {BinOp(lhs=$0, rhs=$4, op=$2)}
  | ElvisExpr
ElvisExpr = AdditiveExpr WS "?:" WS ElvisExpr {Elvis(value=$0, whenNull=$4)}
  | AdditiveExpr
AdditiveExpr = PrefixNotExpr WS ('+' {%Op.ADD}) WS AdditiveExpr {BinOp(lhs=$0, rhs=$4, op=$2)}
  | PrefixNotExpr
PrefixNotExpr = '!' WS PrefixNotExpr
  | Atom
Atom = Ref
  | BindExpr
  | ConstructExpr
  | ArrayExpr
  | Literal
  | FuncCallExpr
  | EnumValue
  | '(' WS PExpr WS ')'

BindExpr = ValRef BinderExpr
BinderExpr = Ref
  | BindExpr
  | '{' WS PExpr WS '}' $2

ConstructExpr: AbstractConstructExpr = TypeName WS UnnamedConstructParams {UnnamedConstructExpr(typeName=$0, params=$2)}
  | TypeName WS NamedConstructParams {NamedConstructExpr(typeName=$0, params=$2)}
UnnamedConstructParams = '(' WS (PExpr (WS ',' WS PExpr)* WS {[$0] + $1})? ')' $2
NamedConstructParams = '(' WS (NamedParam (WS ',' WS NamedParam {[$0] + $1})* WS)? ')' $2
NamedParam = ParamName (WS ':' WS TypeDesc)? WS '=' WS PExpr {NamedParam(name=$0, typeDesc=$1, expr=$5)}

ArrayExpr = '[' WS (PExpr (WS ',' WS PExpr)* WS)? ']' {ArrayExpr(elems=$2{[$0] + $1} ?: [])}

Literal: Literal = "null" {NullLiteral()}
  | ("true" {true} | "false" {false}) {BoolLiteral(value=$0)}
  | '\'' CharChar '\'' {CharLiteral(char=$1)}
  | '"' StrChar* '"' {StrLiteral(chars=$1)}

FuncCallExpr = FuncName WS '(' WS (PExpr (WS ',' WS PExpr)* {[$0] + $1})? ')' {FuncCallExpr(name=$0, params=$4 ?: [])}
FuncName = "ispresent" | "isempty" | "chr" | "str" | "int" | "int32" | "int64"

EnumValue: AbstractEnumValue = <CanonicalEnumValue | ShortenedEnumValue>
CanonicalEnumValue = EnumTypeName '.' Id {CanonicalEnumValue(enumName=$0, valueName=$2)}
// ShortenedEnumValue는 어떤 Enum 값인지 외부의 정보로부터 확실히 알 수 있을 때만 사용 가능
ShortenedEnumValue = '%' Id {ShortenedEnumValue(valueName=$1)}




ValueType: ValueType = "bool" {BoolType()}
  | "char" {CharType()}
  | "string" {StringType()}
EnumTypeName = '%' Id
// EnumTypeDef로 enum의 모든 값이 한군데서 정의되었으면 이값들만 사용되어야 한다.
EnumTypeDef = EnumTypeName WS '{' WS Id (WS ',' WS Id)* WS '}'




TypeDef: @TypeDef = ClassDef
  | SuperDef // SuperDef는 super class가 자신의 sub class를 리스팅하는 식으로 정의하는 것.
  | EnumTypeDef
ClassDef = TypeName WS SuperTypes {AbstractClassDef(name=$0, supers=$2)}
  | TypeName WS ClassParamsDef {ConcreteClassDef(name=$0, supers=[], params=$2)}
  | TypeName WS SuperTypes WS ClassParamsDef {@ConcreteClassDef(name=$0, supers=$2, params=$4)}
SuperTypes = '<' WS (TypeName (WS ',' WS TypeName)* WS {[$0] + $1})? '>' {$2 ?: []}
ClassParamsDef = '(' WS (ClassParamDef (WS ',' WS ClassParamDef)* WS {[$0] + $1})? WS ')' {$2 ?: []}
ClassParamDef = ParamName (WS ':' WS TypeDesc)? {@ClassParamDef(name=$0, typeDesc=$1)}

SuperDef = TypeName WS '{' WS (SubTypes WS)? '}' {@SuperDef(typeName=$0, subs=$4$0)}
SubTypes = SubType (WS ',' WS SubType)* {[$0] + $1}
SubType: SubType = TypeName | ClassDef | SuperDef



TypeDesc = NonNullTypeDesc (WS '?')? {@TypeDesc(typ=$0, optional=ispresent($1))}
NonNullTypeDesc: @NonNullTypeDesc = TypeName
  | '[' WS TypeDesc WS ']' {@ArrayTypeDesc(elemType=$2)}
  | ValueType
  | EnumTypeName
  | TypeDef


TypeName = Id {@TypeName(name=$0)}





=======================


PExpr = TernateryExpr
TernateryExpr = BoolOrExpr WS '?' WS <TernateryExpr> WS ':' WS TernateryExpr
  | BoolOrExpr
BoolOrExpr = BoolAndExpr WS "&&" WS BoolOrExpr
  | BoolAndExpr
BoolAndExpr = BoolEqExpr WS "||" WS BoolAndExpr
  | BoolEqExpr
BoolEqExpr = ElvisExpr ("==" | "!=") WS BoolEqExpr
  | ElvisExpr
ElvisExpr = AdditiveExpr WS "?:" WS ElvisExpr
  | AdditiveExpr
AdditiveExpr = Atom WS ('+') WS AdditiveExpr
  | Atom
Atom = '1'
  | '(' WS PExpr WS ')'
WS = ' '*
