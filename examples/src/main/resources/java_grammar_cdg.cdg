UnicodeInputCharacter = UnicodeEscape
  | RawInputCharacter
UnicodeEscape = '\\' UnicodeMarker HexDigit HexDigit HexDigit HexDigit
UnicodeMarker = 'u'+
HexDigit = '0-9a-zA-Z'
RawInputCharacter = .
LineTerminator = <'\n' | '\r' | "\r\n">
InputCharacter = UnicodeInputCharacter - '\r\n'
Input = InputElement* Sub?
InputElement = WhiteSpace | Comment | Token
Token = Identifier | Keyword | Literal | Separator | Operator
Sub = '\ufffd'
WhiteSpace = ' \t\f' | LineTerminator
WS = WhiteSpace | Comment
Tk = Token

// 3.7
Comment = TraditionalComment | EndOfLineComment
TraditionalComment = "/*" CommentTail
CommentTail = '*' CommentTailStar
  | NotStar CommentTail
CommentTailStar = '/'
  | '*' CommentTailStar
  | NotStarNotSlash CommentTail
NotStar = InputCharacter-'*'
  | LineTerminator
NotStarNotSlash = InputCharacter-'*/'
  | LineTerminator
EndOfLineComment = "//" InputCharacter*

// 3.8
Identifier = IdentifierChars-(Keyword | BooleanLiteral | NullLiteral)
IdentifierChars = <JavaLetter JavaLetterOrDigit*>
JavaLetter = .&Java_letter
JavaLetterOrDigit = .&Java_letter_or_digit
TypeIdentifier = Identifier-"var"

// 3.9
Keyword = "abstract" | "continue" | "for" | "new" | "switch"
  | "assert" | "default" | "if" | "package" | "synchronized"
  | "boolean" | "do" | "goto" | "private" | "this"
  | "break" | "double" | "implements" | "protected" | "throw"
  | "byte" | "else" | "import" | "public" | "throws"
  | "case" | "enum" | "instanceof" | "return" | "transient"
  | "catch" | "extends" | "int" | "short" | "try"
  | "char" | "final" | "interface" | "static" | "void"
  | "class" | "finally" | "long" | "strictfp" | "volatile"
  | "const" | "float" | "native" | "super" | "while" | '_'

// 3.10
Literal = IntegerLiteral
  | FloatingPointLiteral
  | BooleanLiteral
  | CharacterLiteral
  | StringLiteral
  | NullLiteral
// 3.10.1
IntegerLiteral: @IntegerLiteral = DecimalIntegerLiteral
  | HexIntegerLiteral
  | OctalIntegerLiteral
  | BinaryIntegerLiteral
DecimalIntegerLiteral = DecimalNumeral IntegerTypeSuffix? {@DecimalIntegerLiteral(value=$0, typeSuffix=$1)}
HexIntegerLiteral = HexNumeral IntegerTypeSuffix? {@HexIntegerLiteral(value=$0, typeSuffix=$1)}
OctalIntegerLiteral = OctalNumeral IntegerTypeSuffix? {@OctalIntegerLiteral(value=$0, typeSuffix=$1)}
BinaryIntegerLiteral = BinaryNumeral IntegerTypeSuffix? {@BinaryIntegerLiteral(value=$0, typeSuffix=$1)}
IntegerTypeSuffix = 'lL'
DecimalNumeral = '0'
  | NonZeroDigit Digits?
  | NonZeroDigit Underscores Digits
NonZeroDigit = '1-9'
Digits = Digit
  | Digit DigitsAndUnderscores? Digit
Digit = '0' | NonZeroDigit
DigitsAndUnderscores = DigitOrUnderscore+ {$1$0}
DigitOrUnderscore = Digit {[$0]} | '_' {[]}
Underscores = '_'+

HexNumeral = '0' 'xX' HexDigits
HexDigits = HexDigit {[$0]}
  | HexDigit HexDigitsAndUnderscores? HexDigit {[[$0]] ++ $1$0 ++ [[$2]]}
HexDigit = '0-9a-fA-F'
HexDigitsAndUnderscores = HexDigitOrUnderscore+ {$0$0}
HexDigitOrUnderscore = HexDigit {[$0]} | '_' {[]}

OctalNumeral = '0' OctalDigits
  | '0' Underscores OctalDigits
OctalDigits = OctalDigit
  | OctalDigit OctalDigitsAndUnderscores? OctalDigit {[[$0]] ++ $1$0 ++ [[$2]]}
OctalDigit = '0-7'
OctalDigitsAndUnderscores = OctalDigitOrUnderscore+ {$0$0}
OctalDigitOrUnderscore = OctalDigit {[$0]} | '_' {[]}

BinaryNumeral = '0' 'bB' BinaryDigits
BinaryDigits = BinaryDigit
  | BinaryDigit BinaryDigitsAndUnderscores? BinaryDigit {[[$0]] ++ $1$0 ++ [[$2]]}
BinaryDigit = '01'
BinaryDigitsAndUnderscores = BinaryDigitOrUnderscore+ {$0$0}
BinaryDigitOrUnderscore = BinaryDigit {[$0]} | '_' {[]}

// 3.10.2
FloatingPointLiteral = DecimalFloatingPointLiteral
  | HexadecimalFloatingPointLiteral
DecimalFloatingPointLiteral = Digits '.' Digits? ExponentPart? FloatTypeSuffix?
  | '.' Digits ExponentPart? FloatTypeSuffix?
  | Digits ExponentPart FloatTypeSuffix?
  | Digits ExponentPart? FloatTypeSuffix
ExponentPart = ExponentIndicator SignedInteger
ExponentIndicator = 'eE'
SignedInteger = Sign? Digits
Sign = '+\-'
FloatTypeSuffix = 'fFdD'
HexadecimalFloatingPointLiteral = HexSignificand BinaryExponent FloatTypeSuffix?
HexSignificand = HexNumeral '.'?
  | 0 'xX' HexDigits? '.' HexDigits
BinaryExponent = BinaryExponentIndicator SignedInteger
BinaryExponentIndicator = 'pP'

// 3.10.3
BooleanLiteral = "true" | "false"

// 3.10.4
CharacterLiteral = '\'' SingleCharacter '\''
  | '\'' EscapeSequence '\''
SingleCharacter = InputCharacter-'\'\\'

// 3.10.5
StringLiteral = '"' StringCharacter* '"'
StringCharacter = InputCharacter-'"\\'
  | EscapeSequence

// 3.10.6
EscapeSequence = "\\b" // (backspace BS, Unicode \u0008)
  | "\\t" // (horizontal tab HT, Unicode \u0009)
  | "\\n" // (linefeed LF, Unicode \u000a)
  | "\\f" // (form feed FF, Unicode \u000c)
  | "\\r" // (carriage return CR, Unicode \u000d)
  | "\\\"" // (double quote ", Unicode \u0022)
  | "\\'" // (single quote ', Unicode \u0027)
  | "\\\\" // (backslash \, Unicode \u005c)
  | OctalEscape // (octal value, Unicode \u0000 to \u00ff)
OctalEscape = '\\' OctalDigit
  | '\\' OctalDigit OctalDigit
  | '\\' ZeroToThree OctalDigit OctalDigit
OctalDigit = '0-7'
ZeroToThree = '0-3'

// 3.10.7
NullLiteral = "null"

// 3.11
Separator = <'(' | ')' | '{' | '}' | '[' | ']' | ';' | ',' | '.' | "..." | '@' | "::">

Operator = <'=' | '>' | '<' | '!' | '~' | '?' | ':' | "->"
  | "==" | ">=" | "<=" | "!=" | "&&" | "||" | "++" | "--"
  | "+" | "-" | "*" | "/" | "&" | "|" | "^" | "%" | "<<" | ">>" | ">>>"
  | "+=" | "-=" | "*=" | "/=" | "&=" | "|=" | "^=" | "%=" | "<<=" | ">>=" | ">>>=">


// 4.1
Type = PrimitiveType | ReferenceType

// 4.2
PrimitiveType = (Annotation WS)* NumericType
  | (Annotation WS)* Tk&"boolean"
NumericType = IntegralType | FloatingPointType
IntegralType = Tk&("byte" | "short" | "int" | "long" | "char")
FloatingPointType = Tk&("float" | "double")

// 4.3
ReferenceType = ClassOrInterfaceType | TypeVariable | ArrayType
ClassOrInterfaceType = ClassType | InterfaceType
ClassType = Annotation* TypeIdentifier TypeArguments?
  | PackageName '.' Annotation* TypeIdentifier TypeArguments?
  | ClassOrInterfaceType '.' Annotation* TypeIdentifier TypeArguments?
InterfaceType = ClassType
TypeVariable = Annotation? TypeIdentifier
ArrayType = PrimitiveType Dims
  | ClassOrInterfaceType Dims
  | TypeVariable Dims
Dims = DimsDim (WS DimsDim)* {@Dims(dims=[$0] ++ $1$1)}
DimsDim = (Annotation WS)* Tk&'[' WS Tk&']' {@DimsDim(annotations=$0$0)}

// 4.4
TypeParameter = TypeParameterModifier* TypeIdentifier TypeBound?
TypeParameterModifier = Annotation
TypeBound = "extends" TypeVariable
  | "extends" ClassOrInterfaceType AdditionalBound*
AdditionalBound = '&' InterfaceType

// 4.5.1
TypeArguments = '<' TypeArgumentList '>'
TypeArgumentList = TypeArgument (',' TypeArgument)*
TypeArgument = ReferenceType | Wildcard
Wildcard = Annotation* '?' WildcardBounds?
WildcardBounds = "extends" ReferenceType
  | "super" ReferenceType

// 6.5
ModuleName = Identifier
  | ModuleName '.' Identifier
PackageName = Identifier
  | PackageName '.' Identifier
TypeName: @TypeName = TypeIdentifier {@SimpleTypeName(name=$0)}
  | PackageOrTypeName WS Tk&'.' WS TypeIdentifier {@NestedTypeName(parent=$0, name=$4)}
PackageOrTypeName = Identifier
  | PackageOrTypeName '.' Identifier
ExpressionName: @ExpressionName = Identifier {@SimpleExpressionName(name=$0)}
  | AmbiguousName WS Tk&'.' WS Identifier {@NestedExpressionName(parent=$0, name=$4)}
MethodName = Identifier
AmbiguousName: @AmbiguousName = Identifier {@SimpleAmbiguousName(name=$0)}
  | AmbiguousName WS Tk&'.' WS Identifier {@NestedAmbiguousName(parent=$0, name=$4)}

// 7.3
CompilationUnit = OrdinaryCompilationUnit
  | ModularCompilationUnit
OrdinaryCompilationUnit = PackageDeclaration? ImportDeclaration* TypeDeclaration*
ModularCompilationUnit = ImportDeclaration* ModuleDeclaration

// 7.4.1
PackageDeclaration = PackageModifier* package Identifier ('.' Identifier)* ';'
PackageModifier = Annotation

// 7.5
ImportDeclaration = SingleTypeImportDeclaration
  | TypeImportOnDemandDeclaration
  | SingleStaticImportDeclaration
  | StaticImportOnDemandDeclaration
SingleTypeImportDeclaration = "import" TypeName ';'
TypeImportOnDemandDeclaration = "import" PackageOrTypeName '.' '*' ';'
SingleStaticImportDeclaration = "import" "static" TypeName '.' Identifier ';'
StaticImportOnDemandDeclaration = "import" "static" TypeName '.' '*' ';'

// 7.6
TypeDeclaration = ClassDeclaration
  | InterfaceDeclaration
  | ';'

// 7.7
ModuleDeclaration = Annotation* "open"? "module" Identifier ('.' Identifier)* '{' ModuleDirective* '}'
ModuleDirective = "requires" RequiresModifier* ModuleName ';'
  | "exports" PackageName ("to" ModuleName (',' ModuleName)*)? ';'
  | "opens" PackageName ("to" ModuleName (',' ModuleName)*)? ';'
  | "uses" TypeName ';'
  | "provides" TypeName "with" TypeName (',' TypeName)* ';'
RequiresModifier = "transitive" | "static"

// 8.1
ClassDeclaration = NormalClassDeclaration
  | EnumDeclaration
NormalClassDeclaration = ClassModifier* "class" TypeIdentifier TypeParameters? Superclass? Superinterfaces? ClassBody

// 8.1.1
ClassModifier = Annotation | "public" | "protected" | "private"
  | "abstract" | "static" | "final" | "strictfp"

// 8.1.2
TypeParameters = '<' TypeParameterList '>'
TypeParameterList = TypeParameter (',' TypeParameter)*

// 8.1.4
Superclass = "extends" ClassType

// 8.1.5
Superinterfaces = "implements" InterfaceTypeList
InterfaceTypeList = InterfaceType (',' InterfaceType)*

// 8.1.6
ClassBody = '{' ClassBodyDeclaration* '}'
ClassBodyDeclaration = ClassMemberDeclaration
  | InstanceInitializer
  | StaticInitializer
  | ConstructorDeclaration
ClassMemberDeclaration = FieldDeclaration
  | MethodDeclaration
  | ClassDeclaration
  | InterfaceDeclaration
  | ';'

// 8.3
FieldDeclaration = FieldModifier* UnannType VariableDeclaratorList ';'
VariableDeclaratorList = VariableDeclarator (WS Tk&',' WS VariableDeclarator)* {[$0] ++ $1$3}
VariableDeclarator = VariableDeclaratorId (WS Tk&'=' WS VariableInitializer)? {@VariableDeclarator(varId=$0, varInit=$1$3)}
VariableDeclaratorId = Identifier (WS Dims)? {@VariableId(name=$0, dims=$1$1)}
VariableInitializer = Expression
  | ArrayInitializer
UnannType = UnannPrimitiveType
  | UnannReferenceType
UnannPrimitiveType = NumericType
  | Tk&"boolean"
UnannReferenceType = UnannClassOrInterfaceType
  | UnannTypeVariable
  | UnannArrayType
UnannClassOrInterfaceType = UnannClassType
  | UnannInterfaceType
UnannClassType = TypeIdentifier TypeArguments?
  | PackageName '.' Annotation* TypeIdentifier TypeArguments?
  | UnannClassOrInterfaceType '.' Annotation* TypeIdentifier TypeArguments?
UnannInterfaceType = UnannClassType
UnannTypeVariable = TypeIdentifier
UnannArrayType = UnannPrimitiveType Dims
  | UnannClassOrInterfaceType Dims
  | UnannTypeVariable Dims

// 8.3.1
FieldModifier = Annotation | "public" | "protected" | "private"
  | "static" | "final" | "transient" | "volatile"

// 8.4
MethodDeclaration = MethodModifier* MethodHeader MethodBody
MethodHeader = Result MethodDeclarator Throws?
  | TypeParameters Annotation* Result MethodDeclarator Throws?
MethodDeclarator = Identifier '(' (ReceiverParameter ',')? FormalParameterList? ')' Dims?
ReceiverParameter = Annotation* UnannType (Identifier '.')? "this"


// 8.4.1
FormalParameterList = FormalParameter (',' FormalParameter)*
FormalParameter = VariableModifier* UnannType VariableDeclaratorId
  | VariableArityParameter
VariableArityParameter = VariableModifier* UnannType Annotation* "..." Identifier
VariableModifier = Annotation | "final"

// 8.4.3
MethodModifier = Annotation | "public" | "protected" | "private"
  | "abstract" | "static" | "final" | "synchronized" | "native" | "strictfp"

// 8.4.5
Result = UnannType | "void"

// 8.4.6
Throws = "throws" ExceptionTypeList
ExceptionTypeList = ExceptionType (',' ExceptionType)*
ExceptionType = ClassType
  | TypeVariable

// 8.4.7
MethodBody = Block | ';'

// 8.6
InstanceInitializer = Block

// 8.7
StaticInitializer = "static" Block

// 8.8
ConstructorDeclaration = ConstructorModifier* ConstructorDeclarator Throws? ConstructorBody
ConstructorDeclarator = TypeParameters? SimpleTypeName
  | '(' (ReceiverParameter ',')? FormalParameterList? ')'
SimpleTypeName = TypeIdentifier

// 8.8.3
ConstructorModifier = Annotation | "public" | "protected" | "private"

// 8.8.7
ConstructorBody = '{' ExplicitConstructorInvocation? BlockStatements? '}'

// 8.8.7.1
ExplicitConstructorInvocation = TypeArguments? "this" '(' ArgumentList? ')' ';'
  | TypeArguments? "super" '(' ArgumentList? ')' ';'
  | ExpressionName '.' TypeArguments? "super" '(' ArgumentList? ')' ';'
  | Primary '.' TypeArguments? "super" '(' ArgumentList? ')' ';'

// 8.9
EnumDeclaration = ClassModifier* "enum" TypeIdentifier Superinterfaces? EnumBody

// 8.9.1
EnumBody = '{' EnumConstantList? ','? EnumBodyDeclarations? '}'
EnumConstantList = EnumConstant (',' EnumConstant)*
EnumConstant = EnumConstantModifier* Identifier ('(' ArgumentList? ')')? ClassBody?
EnumConstantModifier = Annotation

// 8.9.2
EnumBodyDeclarations = ';' ClassBodyDeclaration*

// 9.1
InterfaceDeclaration = NormalInterfaceDeclaration
  | AnnotationTypeDeclaration
NormalInterfaceDeclaration = InterfaceModifier* "interface" TypeIdentifier TypeParameters? ExtendsInterfaces? InterfaceBody

// 9.1.1
InterfaceModifier = Annotation | "public" | "protected" | "private"
  | "abstract" | "static" | "strictfp"

// 9.1.3
ExtendsInterfaces = "extends" InterfaceTypeList

// 9.1.4
InterfaceBody = '{' InterfaceMemberDeclaration* '}'
InterfaceMemberDeclaration = ConstantDeclaration
  | InterfaceMethodDeclaration
  | ClassDeclaration
  | InterfaceDeclaration
  | ';'

// 9.3
ConstantDeclaration = ConstantModifier* UnannType VariableDeclaratorList ';'
ConstantModifier = Annotation | "public" | "static" | "final"

// 9.4
InterfaceMethodDeclaration = InterfaceMethodModifier* MethodHeader MethodBody
InterfaceMethodModifier = Annotation | "public" | "private"
  | "abstract" | "default" | "static" | "strictfp"

// 9.6
AnnotationTypeDeclaration = InterfaceModifier* '@' "interface" TypeIdentifier AnnotationTypeBody

// 9.6.1
AnnotationTypeBody = '{' AnnotationTypeMemberDeclaration* '}'
AnnotationTypeMemberDeclaration = AnnotationTypeElementDeclaration
  | ConstantDeclaration
  | ClassDeclaration
  | InterfaceDeclaration
  | ';'
AnnotationTypeElementDeclaration = AnnotationTypeElementModifier* UnannType Identifier '(' ')' Dims? DefaultValue? ';'
AnnotationTypeElementModifier = Annotation "public" | "abstract"

// 9.6.2
DefaultValue = "default" ElementValue

// 9.7
Annotation = NormalAnnotation
  | MarkerAnnotation
  | SingleElementAnnotation

// 9.7.1
NormalAnnotation = '@' TypeName '(' ElementValuePairList? ')'
ElementValuePairList = ElementValuePair (',' ElementValuePair)*
ElementValuePair = Identifier '=' ElementValue
ElementValue = ConditionalExpression
  | ElementValueArrayInitializer
  | Annotation
ElementValueArrayInitializer = '{' ElementValueList? ','? '}'
ElementValueList = ElementValue (',' ElementValue)*

// 9.7.2
MarkerAnnotation = '@' TypeName

// 9.7.3
SingleElementAnnotation = '@' TypeName '(' ElementValue ')'

// 10
ArrayInitializer = Tk&'{' (WS VariableInitializerList)? (WS Tk&',')? WS Tk&'}' {$1$1}
VariableInitializerList = VariableInitializer (WS ',' WS VariableInitializer)* {[$0] ++ $1$3}

// 14.2
Block = Tk&'{' (WS BlockStatements)? WS Tk&'}' {@Block(stmts=$1$1)}
BlockStatements = BlockStatement (WS BlockStatement)* {[$0] ++ $1$1}
BlockStatement = LocalVariableDeclarationStatement
  | ClassDeclaration
  | Statement

// 14.4
LocalVariableDeclarationStatement = LocalVariableDeclaration WS Tk&';' $0
LocalVariableDeclaration = (VariableModifier WS)* LocalVariableType WS VariableDeclaratorList {@LocalVariableDeclaration(varMods=$0$0, varType=$1, varDeclators=$3)}
LocalVariableType = UnannType | Tk&"var"

// 14.5
Statement: @Statement = StatementWithoutTrailingSubstatement
  | LabeledStatement
  | IfThenStatement
  | IfThenElseStatement
  | WhileStatement
  | ForStatement
StatementNoShortIf = StatementWithoutTrailingSubstatement
  | LabeledStatementNoShortIf
  | IfThenElseStatementNoShortIf
  | WhileStatementNoShortIf
  | ForStatementNoShortIf
StatementWithoutTrailingSubstatement = Block
  | EmptyStatement
  | ExpressionStatement
  | AssertStatement
  | SwitchStatement
  | DoStatement
  | BreakStatement
  | ContinueStatement
  | ReturnStatement
  | SynchronizedStatement
  | ThrowStatement
  | TryStatement

// 14.6
EmptyStatement = Tk&';' {@EmptyStatement()}

// 14.7
LabeledStatement = Identifier WS Tk&':' WS Statement {@LabeledStatement(label=$0, statement=$4)}
LabeledStatementNoShortIf = Identifier WS Tk&':' WS StatementNoShortIf {LabeledStatement($0, $4)}

// 14.8
ExpressionStatement = StatementExpression WS Tk&';' {@ExpressionStatement(expr=$0)}
StatementExpression = Assignment
  | PreIncrementExpression
  | PreDecrementExpression
  | PostIncrementExpression
  | PostDecrementExpression
  | MethodInvocation
  | ClassInstanceCreationExpression

// 14.9
IfThenStatement = Tk&"if" WS Tk&'(' WS Expression WS Tk&')' WS Statement {@IfStatement(condition=$4, then=$8, else=null)}
IfThenElseStatement = Tk&"if" WS Tk&'(' WS Expression WS Tk&')' WS StatementNoShortIf WS Tk&"else" WS Statement {IfStatement($4, $8, $12)}
IfThenElseStatementNoShortIf = Tk&"if" WS Tk&'(' WS Expression WS Tk&')' WS StatementNoShortIf WS Tk&"else" WS StatementNoShortIf {IfStatement($4, $8, $12)}

// 14.10
AssertStatement = "assert" Expression ';'
  | "assert" Expression ':' Expression ';'

// 14.11
SwitchStatement = "switch" '(' Expression ')' SwitchBlock
SwitchBlock = '{' SwitchBlockStatementGroup* SwitchLabel* '}'
SwitchBlockStatementGroup = SwitchLabels BlockStatements
SwitchLabels = SwitchLabel SwitchLabel*
SwitchLabel = "case" ConstantExpression ':'
  | "case" EnumConstantName ':'
  | "default" ':'
EnumConstantName = Identifier

// 14.12
WhileStatement = Tk&"while" WS Tk&'(' WS Expression WS Tk&')' WS Statement {@WhileStatement(condition=$4, loopbody=$8)}
WhileStatementNoShortIf = Tk&"while" WS Tk&'(' WS Expression WS Tk&')' WS StatementNoShortIf {WhileStatement($4, $8)}

// 14.13
DoStatement = Tk&"do" WS Statement WS Tk&"while" WS Tk&'(' WS Expression WS Tk&')' WS Tk&';' {@DoStatement(loopbody=$2, condition=$8)}

// 14.14
ForStatement = BasicForStatement
  | EnhancedForStatement
ForStatementNoShortIf = BasicForStatementNoShortIf
  | EnhancedForStatementNoShortIf

// 14.14.1
BasicForStatement = Tk&"for" WS Tk&'(' (WS ForInit)? WS Tk&';' (WS Expression)? WS Tk&';' (WS ForUpdate)? WS Tk&')' WS Statement
        {@ForStatement(init=$3$1, condition=$6$1, update=$9$1, loopbody=$13)}
BasicForStatementNoShortIf = Tk&"for" WS Tk&'(' (WS ForInit)? WS Tk&';' (WS Expression)? WS Tk&';' (WS ForUpdate)? WS Tk&')' WS StatementNoShortIf
        {ForStatement($3$1, $6$1, $9$1, $13)}
ForInit = StatementExpressionList
  | LocalVariableDeclaration
ForUpdate = StatementExpressionList
StatementExpressionList = StatementExpression (WS Tk&',' WS StatementExpression)* {@StatementExpressions(exprs=[$0] ++ $1$3)}

// 14.14.2
EnhancedForStatement = Tk&"for" WS Tk&'(' (WS VariableModifier)* WS LocalVariableType WS VariableDeclaratorId WS Tk&':' WS Expression WS Tk&')' WS Statement
        {@EnhancedForStatement(varModifiers=$3$1, varType=$5, varDecl=$7, iterator=$11, loopbody=$15)}
EnhancedForStatementNoShortIf = Tk&"for" WS Tk&'(' (WS VariableModifier)* WS LocalVariableType WS VariableDeclaratorId WS Tk&':' WS Expression WS Tk&')' WS StatementNoShortIf
        {EnhancedForStatement(varModifiers=$3$1, varType=$5, varDecl=$7, iterator=$11, loopbody=$15)}

// 14.15
BreakStatement = Tk&"break" (WS Identifier)? WS Tk&';' {@BreakStatement(label=$1$1)}

// 14.16
ContinueStatement = Tk&"continue" (WS Identifier)? WS Tk&';' {@ContinueStatement(label=$1$1)}

// 14.17
ReturnStatement = Tk&"return" (WS Expression)? WS Tk&';' {@ReturnStatement(expr=$1$1)}

// 14.18
ThrowStatement = Tk&"throw" WS Expression WS Tk&';' {@ThrowStatement(expr=$2)}

// 14.19
SynchronizedStatement = Tk&"synchronized" WS Tk&'(' WS Expression WS Tk&')' WS Block {@SynchronizedStatement(monitor=$4, body=$8)}

// 14.20
TryStatement = Tk&"try" WS Block WS Catches {@TryStatement(tryBlock=$2, catches=[$4], finallyBlock=null)}
  | Tk&"try" WS Block (WS Catches)? WS Finally {TryStatement($2, $3$1, $5)}
  | TryWithResourcesStatement
Catches = CatchClause (WS CatchClause)* {[$0] ++ $1$1}
CatchClause = Tk&"catch" WS Tk&'(' WS CatchFormalParameter WS Tk&')' WS Block {@CatchClause(catchedParam=$4, catchBlock=$8)}
CatchFormalParameter = (VariableModifier WS)* CatchType WS VariableDeclaratorId {@CatchFormalParameter(varMods=$0$0, catchType=$1, varDecl=$3)}
CatchType = UnannClassType (WS Tk&'|' WS ClassType)* {@CatchType(classTypes=[$0] ++ $1$3)}
Finally = Tk&"finally" WS Block {@FinallyBlock(body=$2)}

// 14.20.3
TryWithResourcesStatement = Tk&"try" WS ResourceSpecification WS Block (WS Catches)? (WS Finally)? {@TryWithResourcesStatement(resource=$2, body=$4, catches=$5$1, finally=$6$1)}
ResourceSpecification = Tk&'(' WS ResourceList (WS ';')? WS Tk&')' {@ResourceSpecification(resources=$2)}
ResourceList = Resource (WS ';' WS Resource)* {[$0] ++ $1$3}
Resource = (VariableModifier WS)* LocalVariableType WS Identifier WS Tk&'=' WS Expression {@Resource(varMods=$0$0, varType=$1, varName=$3, expr=$7)}
  | VariableAccess
VariableAccess = ExpressionName
  | FieldAccess

// 15.2
Expression: @Expression = LambdaExpression
  | AssignmentExpression

// 15.8
Primary: @Primary = PrimaryNoNewArray
  | ArrayCreationExpression
PrimaryNoNewArray = Literal
  | ClassLiteral
  | "this" {@This(outerType=null)}
  | TypeName WS Tk&'.' WS Tk&"this" {This($0)}
  | Tk&'(' WS Expression WS Tk&')' {@Paren(expr=$2)}
  | ClassInstanceCreationExpression
  | FieldAccess
  | ArrayAccess
  | MethodInvocation
  | MethodReference

// 15.8.2
ClassLiteral: @ClassLiteral = TypeName (WS Tk&'[' WS Tk&']')* WS Tk&'.' WS Tk&"class" {@TypeClassLiteral(type=$0, dims=$1$1)}
  | NumericType (WS Tk&'[' WS Tk&']')* WS Tk&'.' WS Tk&"class" {@NumericTypeLiteral(type=$0, dims=$1$1)}
  | Tk&"boolean" (WS Tk&'[' WS Tk&']')* WS Tk&'.' WS Tk&"class" {@BooleanTypeLiteral(dims=$1$1)}
  | Tk&"void" WS Tk&'.' WS Tk&"class" {@VoidTypeLiteral()}

// 15.9
ClassInstanceCreationExpression: @ClassInstanceCreationExpression = UnqualifiedClassInstanceCreationExpression
  | ExpressionName WS Tk&'.' WS UnqualifiedClassInstanceCreationExpression {@ExpressionNameBoundClassInstanceCreation(bound=$0, creation=$4)}
  | Primary WS Tk&'.' WS UnqualifiedClassInstanceCreationExpression {@PrimaryBoundClassInstanceCreation(bound=$0, creation=$4)}
UnqualifiedClassInstanceCreationExpression = Tk&"new" (WS TypeArguments)? WS ClassOrInterfaceTypeToInstantiate WS Tk&'(' (WS ArgumentList)? WS Tk&')' (WS ClassBody)?
        {@UnqualifiedClassInstanceCreationExpression(typeArgs=$1$1, classType=$3, args=$6$1, classBody=$9$1)}
ClassOrInterfaceTypeToInstantiate = (Annotation WS)* Identifier (WS Tk&'.' (WS Annotation)* WS Identifier {@NestedClassName(annot=$2$1, name=$4)})* (WS TypeArgumentsOrDiamond)?
        {@ClassOrInterfaceTypeToInstantiate(annots=$0$0, name=$1, nestedName=$2$5, typeArgs=$3$1)}
TypeArgumentsOrDiamond = TypeArguments
  | Tk&"<" WS Tk&">"

// 15.10
ArrayCreationExpression: @ArrayCreationExpression = Tk&"new" WS PrimitiveType WS DimExprs (WS Dims)? {@PrimitiveArrayCreation(typeName=$2, dimExprs=$4, dims=$5$1, inits=null)}
  | Tk&"new" WS ClassOrInterfaceType WS DimExprs (WS Dims)? {@ClassArrayCreation(typeName=$2, dimExprs=$4, dims=$5$1, inits=null)}
  | Tk&"new" WS PrimitiveType WS Dims WS ArrayInitializer {@PrimitiveArrayCreation($2, [], $4, $6)}
  | Tk&"new" WS ClassOrInterfaceType WS Dims WS ArrayInitializer {@ClassArrayCreation($2, [], $4, $6)}
DimExprs: [DimExpr] = DimExpr (WS DimExpr)* {[$0] ++ $1$1}
DimExpr = (Annotation WS)* Tk&'[' WS Expression WS Tk&']' {@DimExpr(annotations=$0$0, size=$3)}

// 15.10.3
ArrayAccess = ExpressionName WS Tk&'[' WS Expression WS Tk&']' {@ArrayAccess(arrayExpr=$0, indexExpr=$4)}
  | PrimaryNoNewArray WS Tk&'[' WS Expression WS ']' {ArrayAccess($0, $4)}

// 15.11
FieldAccess: @FieldAccess = Primary WS Tk&'.' WS Identifier {@PrimaryFieldAccess(targetExpr=$0, fieldName=$4)}
  | Tk&"super" WS Tk&'.' WS Identifier {@SuperFieldAccess(superTypeName=null, fieldName=$4)}
  | TypeName WS Tk&'.' WS Tk&"super" WS Tk&'.' WS Identifier {@SuperFieldAccess($0, $8)}

// 15.12
MethodInvocation: @MethodInvocation = MethodName WS Tk&'(' (WS ArgumentList)? WS )' {@InstanceMethodInvoke(methodName=$0, arguments=$3$1)}
  | TypeName WS Tk&'.' (WS TypeArguments)? WS Identifier WS TK&'(' (WS ArgumentList)? WS Tk&')' {@TypeMethodInvoke(typeName=$0, typeArg=$3$1, methodName=$5, args=$8$1)}
  | ExpressionName WS Tk&'.' (WS TypeArguments)? WS Identifier WS Tk&'(' (WS ArgumentList)? WS Tk&')' {@ExprNameMethodInvoke(exprName=$0, typeArg=$3$1, methodName=$5, args=$8$1)}
  | Primary WS Tk&'.' (WS TypeArguments)? WS Identifier WS Tk&'(' (WS ArgumentList)? WS Tk&')' {@PrimaryMethodInvoke(expr=$0, typeArg=$3$1, methodName=$5, args=$8$1)}
  | Tk&"super" WS Tk&'.' (WS TypeArguments)? WS Identifier WS Tk&'(' (WS ArgumentList)? WS Tk&')' {@SuperMethodInvoke(typeArg=$3$1, methodName=$5, args=$8$1)}
  | TypeName WS Tk&'.' WS Tk&"super" WS Tk&'.' (WS TypeArguments)? WS Identifier WS Tk&'(' (WS ArgumentList)? WS Tk&')'
        {@TypeSuperMethodInvoke(typeName=$0, typeArg=7$1, methodName=$9, args=$12$1)}
ArgumentList = Expression (WS Tk&',' WS Expression)* {@ArgumentList(args=$0 ++ $1$3)}

// 15.13
MethodReference: @MethodReference = ExpressionName WS Tk&"::" (WS TypeArguments)? WS Identifier {@InstanceMethodRef(expr=$0, typeArg=$3$1, methodName=$5)}
  | Primary WS Tk&"::" (WS TypeArguments)? WS Identifier {@PrimaryMethodRef(expr=$0, typeArg=$3$1, methodName=$5)}
  | ReferenceType WS Tk&"::" (WS TypeArguments)? WS Identifier {@ReferenceTypeMethodRef(expr=$0, typeArg=$3$1, methodName=$5)}
  | Tk&"super" WS Tk&"::" (WS TypeArguments)? WS Identifier {@SuperMethodRef(typeArg=$3$1, methodName=$5)}
  | TypeName WS Tk&'.' WS Tk&"super" WS Tk&"::" (WS TypeArguments)? WS Identifier {@TypeSuperMethodRef(expr=$0, typeArg=$7$1, methodName=$9)}
  | ClassType WS Tk&"::" (WS TypeArguments)? WS Tk&"new" {@NewClassMethodRef(classType=$0, typeArg=$3$1)}
  | ArrayType WS Tk&"::" WS Tk&"new" {@NewArrayMethodRef(arrayType=$0, typeArg=$3$1)}

// 15.14
PostfixExpression = Primary
  | ExpressionName
  | PostIncrementExpression
  | PostDecrementExpression

// 15.14.2
PostIncrementExpression = PostfixExpression WS Tk&"++" {@PostUnaryOp(expr=$0, op=$2)}

// 15.14.3
PostDecrementExpression = PostfixExpression WS Tk&"--" {PostUnaryOp(expr=$0, op=$2)}

// 15.15
UnaryExpression: @UnaryExpression = PreIncrementExpression
  | PreDecrementExpression
  | '+' UnaryExpression {@PreUnaryOp(op=$0, expr=$2)}
  | '-' UnaryExpression {PreUnaryOp($0, $2)}
  | UnaryExpressionNotPlusMinus
PreIncrementExpression = Tk&"++" WS UnaryExpression {PreUnaryOp($0, $2)}
PreDecrementExpression = Tk&"--" WS UnaryExpression {PreUnaryOp($0, $2)}
UnaryExpressionNotPlusMinus = PostfixExpression
  | Tk&'~' WS UnaryExpression {PreUnaryOp($0, $2)}
  | Tk&'!' WS UnaryExpression {PreUnaryOp($0, $2)}
  | CastExpression

// 15.16
CastExpression: @CastExpression = Tk&'(' WS PrimitiveType WS Tk&')' WS UnaryExpression {@PremitiveCast(typename=$2, target=$6)}
  | Tk&'(' WS ReferenceType (WS AdditionalBound)* WS Tk&')' WS UnaryExpressionNotPlusMinus {@ReferenceCast(typename=$2, additionalBounds=$3$1, target=$7)}
  | Tk&'(' WS ReferenceType (WS AdditionalBound)* WS Tk&')' WS LambdaExpression {ReferenceCast($2, $3$1, $7)}

// 15.17
MultiplicativeExpression = UnaryExpression
  | MultiplicativeExpression WS Tk&'*' WS UnaryExpression {BinOp($2, $0, $4)}
  | MultiplicativeExpression WS Tk&'/' WS UnaryExpression {BinOp($2, $0, $4)}
  | MultiplicativeExpression WS Tk&'%' WS UnaryExpression {BinOp($2, $0, $4)}

// 15.18
AdditiveExpression = MultiplicativeExpression
  | AdditiveExpression WS Tk&'+' WS MultiplicativeExpression {BinOp($2, $0, $4)}
  | AdditiveExpression WS Tk&'-' WS MultiplicativeExpression {BinOp($2, $0, $4)}

// 15.19
ShiftExpression = AdditiveExpression
  | ShiftExpression WS Tk&"<<" WS AdditiveExpression {BinOp($2, $0, $4)}
  | ShiftExpression WS Tk&">>" WS AdditiveExpression {BinOp($2, $0, $4)}
  | ShiftExpression WS Tk&">>>" WS AdditiveExpression {BinOp($2, $0, $4)}

// 15.20
RelationalExpression = ShiftExpression
  | RelationalExpression WS Tk&"<" WS ShiftExpression {BinOp($2, $0, $4)}
  | RelationalExpression WS Tk&">" WS ShiftExpression {BinOp($2, $0, $4)}
  | RelationalExpression WS Tk&"<=" WS ShiftExpression {BinOp($2, $0, $4)}
  | RelationalExpression WS Tk&">=" WS ShiftExpression {BinOp($2, $0, $4)}
  | RelationalExpression WS Tk&"instanceof" WS ReferenceType {BinOp($2, $0, $4)}

// 15.21
EqualityExpression = RelationalExpression
  | EqualityExpression WS Tk&"==" WS RelationalExpression {BinOp($2, $0, $4)}
  | EqualityExpression WS Tk&"!=" WS RelationalExpression {BinOp($2, $0, $4)}

// 15.22
AndExpression = EqualityExpression
  | AndExpression WS Tk&'&' WS EqualityExpression {BinOp($2, $0, $4)}
ExclusiveOrExpression = AndExpression
  | ExclusiveOrExpression WS Tk&'^' WS AndExpression {BinOp($2, $0, $4)}
InclusiveOrExpression = ExclusiveOrExpression
  | InclusiveOrExpression WS Tk&'|' WS ExclusiveOrExpression {BinOp($2, $0, $4)}

// 15.23
ConditionalAndExpression = InclusiveOrExpression
  | ConditionalAndExpression WS Tk&"&&" WS InclusiveOrExpression {BinOp($2, $0, $4)}

// 15.24
ConditionalOrExpression = ConditionalAndExpression
  | ConditionalOrExpression WS Tk&"||" WS ConditionalAndExpression {@BinOp(op=$2, lhs=$0, rhs=$4)}

// 15.25
ConditionalExpression = ConditionalOrExpression
  | ConditionalOrExpression WS Tk&'?' WS Expression WS Tk&':' WS ConditionalExpression {@Conditional(condition=$0, yes=$4, no=$8)}
  | ConditionalOrExpression WS Tk&'?' WS Expression WS Tk&':' WS LambdaExpression {Conditional($0, $4, $8)}

// 15.26
AssignmentExpression = ConditionalExpression
  | Assignment
Assignment = LeftHandSide WS AssignmentOperator WS Expression {@Assignment(lhs=$0, op=$2, rhs=$4)}
LeftHandSide = ExpressionName
  | FieldAccess
  | ArrayAccess
AssignmentOperator = Tk&("=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=")

// 15.27
LambdaExpression = LambdaParameters WS Tk&"->" WS LambdaBody {@LambdaExpression(params=$0, body=$4)}

// 15.27.1
LambdaParameters: @LambdaParameters = '(' (WS LambdaParameterList)? WS ')' $1$1
  | Identifier {@LambdaIdParams(params=[$0])}
LambdaParameterList = LambdaParameter (WS Tk&',' WS LambdaParameter)* {@LambdaVerboseParams(params=$0 ++ $1$3)}
  | Identifier (WS Tk&',' WS Identifier)* {LambdaIdParams($0 ++ $1$3)}
LambdaParameter = VariableModifier* LambdaParameterType VariableDeclaratorId
  | VariableArityParameter
LambdaParameterType = UnannType | "var"

// 15.27.2
LambdaBody = Expression
  | Block

// 15.28
ConstantExpression = Expression
