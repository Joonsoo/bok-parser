

결국 필요한 것
  type hierarchy: 생성할 클래스의 계층 구조 트리
  enum types
  astifier

type(elem) returns Type

- BindExpr 은 복잡하니까 우선 나중에..

type(RawRef): Node
type(ValRef) = ValRef가 가리키는 elem의 type
type(ConstructExpr): NamedConstructExpr의 TypeName
type(FuncCall) = Function name에 따라 다름
type(Literal)
  type(NullLiteral): any? nothing?
  type(BoolLiteral): bool
  type(CharLiteral): char
  type(StrLiteral): string
type(EnumValue)
  type(CanonicalEnumValue) = EnumValue의 EnumType
  type(ShortenedEnumValue)는.. 복잡하니까 일단 나중에




- 결국 결과물은:
  - 필요한 타입 정의들
  - Ref로 가리키는 값을 추출해오는 astifier expression
  - Ref로 얻어온 값을 PExpr로 가공하는 valueifier expression
  - BindExpr의 경우도 ref의 확장된 형태
- 여기서 astifier와 valueifier의 결과대로 코드 생성해서 컴파일했을 때


ClassType








BinSymbol: BinSymbol = BinSymbol WS '&' WS PreUnSymbol {JoinSymbol(body=$0, join=$4)}
  | BinSymbol WS '-' WS PreUnSymbol {ExceptSymbol(body=$0, except=$4)}
  | PreUnSymbol

-> Node의 symbol이 150이면
  BinSymbol WS '&' WS PreUnSymbol {JoinSymbol(body=$0, join=$4)}
  : 150 = sequence 전체
    149 = BinSymbol
    152 = PreUnSymbol
    -> let body = Unbind(150, InputNode)
    -> $0은 BinSymbol을 가리키고 있음.
    -> $0을 얻는 방법: Unbind(149, SeqRef(body, 0))
      -> Unbind를 codegen할 때 149가 Nonterminal이라서 matchBinSymbol을 추가로 호출
    -> $4를 얻는 방법: Unbind(152, SeqRef(body, 4))
  : $0 -> Unbind(149, SeqRef(InputNode, 0))
    $4 -> Unbind(152, SeqRef(InputNode, 4))
    symbol 150 -> CreateObj(JoinSymbol, Unbind(149, SeqRef(InputNode, 0)), Unbind(152, SeqRef(InputNode, 4)))
    $0 refers to symbol BinSymbol
    $4 refers to symbol PreUnSymbol
    Param(JoinSymbol, 0(body)) takes $0(which refers to BinSymbol)
    Param(JoinSymbol, 1(join)) takes $4(which refers to PreUnSymbol)
    symbol 150 is class JoinSymbol


BinSymbol: BinSymbol = BinSymbol WS '&' WS PreUnSymbol {JoinSymbol(body=$0, join=$4)}









CallParams = '(' WS
  (
    PExpr
      -> Unbind(PExpr, SeqRef(InputNode, 0)): type(PExpr)
    (WS ',' WS PExpr)*
      "WS ',' WS PExpr" returns symbol PExpr
      "WS ',' WS PExpr"
        -> Unbind(PExpr, SeqRef(InputNode, 3)): type(PExpr)
      -> UnrollRepeat(SeqRef(Unbind(**, SeqRef(InputNode, 3)), 1), Unbind(PExpr, SeqRef(InputNode, 3)))
        : [type(PExpr)]
    WS -> ..
    {[$0] + $1}
      : $0 -> Unbind(PExpr, SeqRef(InputNode, 0)) : type(PExpr)
        $1 -> UnrollRepeat(SeqRef(Unbind(**, SeqRef(InputNode, 3)), 1), Unbind(PExpr, SeqRef(InputNode, 3)))
                      : [type(PExpr)]
        [$0]: [type(PExpr)]
        [$0] + $1: [type(PExpr)]
      -> BinOp(+,
           Unbind(PExpr, SeqRef(InputNode, 0)) : [type(PExpr)],
           UnrollRepeat(SeqRef(Unbind(**, SeqRef(InputNode, 3)), 1), Unbind(PExpr, SeqRef(InputNode, 3))) : [type(PExpr)]
         ) : [type(PExpr)]
         * BinOp(+, [T], [T]): [T], BinOp(+, str, str): str
  )?
  ')'
  {$2 ?: []}

valueify(ref) = valueify(가리키는 elem)
ref된 elem에 대해 ElemExpr과 type constructor?를 계산해야 함. 이 때 ref의 정보도 필요함.
- elem이 symbol이면:
  - rawref이면 항상 Unbind(symbol, SeqRef(InputNode, <index>)): Node
    - 가리키는 인덱스가 symbol이 아니고 processor이면 오류
    - 가리키는 symbol이 A&B, A-B, ^A, !A가 아닌데 CondSymPath가 비어있지 않으면 에러
    - 가리키는 symbol이 A&B, A-B, ^A, !A가 아닐때 CondSymPath 처리는 TODO
  * index는 elem 중 processor를 제외한 symbol들만 고려한 index이므로 사용자가 적은 index와는 다를 수 있다.
  - terminal, string, emptyseq이면 Unbind(symbol, SeqRef(InputNode, <index>)): Node
    - CondSymPath가 비어있지 않으면 에러
  - nonterminal A이면 MatchNonterminal(A, Unbind(A, SeqRef(InputNode, <index>))) : type(A)
    - CondSymPath가 비어있지 않으면 에러
  - elem이 A&B, A-B, ^A, !A이면
    - A&B인 경우(나머지도 마찬가지):
      - CondSymPath가 비어있으면 JoinBodyOf(symbol, Unbind(symbol, SeqRef(InputNode, <index>))) : type(A)
        - 만약 A가 또다시 A&B, A-B, ^A, !A이면 conditional nonterminal이 안 나올때까지 **BodyOf를 붙임
      - CondSymPath가 비어있지 않으면 JoinBodyOf와 JoinCondOf로 expression 생성
        - 그 결과물이 conditional nonterminal이면 **BodyOf를 붙임
  - valueify( A? )
    - UnrollOptional(Unbind(A?, SeqRef(InputNode, <index>)), elem => valueify(elem)): type(A)?
      - valueify(elem)은 type(A)를 리턴할 것
  - valueify( A* ) 혹은 valueify( A+ )는
    - UnrollRepeat(* or +, Unbind(A?, SeqRef(InputNode, <index>)), elem => valueify(elem)): [type(A)]
      - valueify(elem)은 type(A)를 리턴할 것
  - valueify( (A0 A1 ... An) ) = valueify(An)
  - valueify( (A0 ... An | B0 ... Bn | ...) )
    = UnrollChoices("A0 ... An" -> valueify(An).withInputNode(Unbind("A0 ... An", SeqRef(InputNode, <index>))), ...):
        {type(An), type(Bn), ...}
  - valueify( <A0 ... An> )
    = valueify(An).withInputNode(UnrollLongest(**, Unbind(<A0 ... An>, SeqRef(InputNode, <index>))))
  - valueify( <A0 ... An | ...> )
    = UnrollChoices("A0 ... An" -> valueify(An).withInputNode(UnrollLongest(**, Unbind("A0 ... An"), SeqRef(InputNode, <index>))), ...):
        {type(An), type(Bn), ...}
- elem이 processor이면
  - rawref이거나 CondSymPath가 비어있지 않으면 오류
  - valueify(ref)
  - valueify(BindExpr) TODO 복잡해..
  - valueify(NamedConstructExpr ClassName) = ConstructExpr(params 각각 valueify): class<ClassName>
  - valueify(FuncCallOrConstructExpr) TODO 이거도 쉽지 않음
  - valueify([a, b, c, ...]) = ArrayExpr([valueify(a), valueify(b), valueify(c), ...])
    - valueify(a): A, valueify(b): B, valueify(c): C, ...이면
      valueify([a, b, c, ...]): {A, B, C}
  - valueify(Literal)
    - valueify(null) = null: null (null type)
    - valueify(true) = true: bool, valueify(false) = false: bool
    - valueify('c') = 'c': char
    - valueify("string") = "string": string
  - valueify(EnumValue)
    - valueify(%Name.Value) = %Name.Value: enum %Name
    - valueify(%Value) = %??.Value: unspecified enum
  - valueify('(' PExpr ')') = valueify(PExpr)
  - valueify(! expr) = PrefixOp(!, valueify(expr)): bool. valueify(expr):bool 이어야 함
  - valueify(a + b) = BinOp(+, valueify(a), valueify(b))
    - valueify(a):string, valueify(b): str이면 :string
    - valueify(a):[T], valueify(b): [T]이면 :[T]
    - valueify(a):[A], valueify(b): [B]이면 :[{A, B}]
    - 그 외의 경우엔 오류
  - valueify(a ?: b) = ElvisOp(valueify(a), valueify(b))
    - (valueify(A): A?), (valueify(b): B)이면(B는 nullable), valueify(a ?: b): {A, B}
      - a가 null이면 B가 되기 때문에 리턴값이 A?일 수는 없음.
  - valueify(a == b) = BinOp(&&, valueify(a), valueify(b)): bool,
    valueify(a != b) = BinOp(&&, valueify(a), valueify(b)): bool
    - user defined class의 equality는 다소 복잡하기 때문에, bool, char, string만 지원.
    - type(a) == type(b) 이어야 함
  - valueify(a || b) = BinOp(!!, valueify(a), valueify(b)): bool
    - type(a) == type(b) == bool이어야 함
  - valueify(a && b) = BinOp(&&, valueify(a), valueify(b)): bool
    - type(a) == type(b) == bool이어야 함
  - valueify(a ? b : c)
    - valueify(a):bool, valueify(b):B, valueify(c):C이면
    - valueify(a ? b : c): {B, C}



- 클래스 인자나, 넌터미널(이나 추후 PExpr)의 타입이 명시적으로 ": ~~"로 정의되어 있지 않은 경우에는, 그 위치에 넣어주는
  값(예를 들어 클래스를 생성할 때 그 인자에 주는 값)의 타입들을 보고 bottom up으로 inference한다.
- 하지만 사용자가 타입을 명시적으로 지정해 주었으면 그 타입이 받을 수 없는 expression을 주는 경우 오류 발생.

- union type은 클래스 계층 구조상에서 해당 타입에 속한 모든 타입을 tightly cover하는 가장 낮은 위치의 abstract type으로
  치환한다

